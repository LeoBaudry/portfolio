---
// src/components/Icon.astro
export interface Props {
  name: string;
  class?: string;
  hoverGradient?: 'orange' | 'green';
  color?: string; // NOUVELLE PROP
}
const { name, class: className, hoverGradient, color } = Astro.props;
const icons = import.meta.glob('/src/assets/*.svg', { query: '?raw', import: 'default' });
const iconPath = `/src/assets/${name}.svg`;

if (!icons[iconPath]) {
  console.error(`L'icône "${name}" n'a pas été trouvée dans /src/assets/`);
  return null;
}

let svgContent = String(await icons[iconPath]());
const uniqueId = `${name}-${Math.random().toString(36).substr(2, 9)}`;

if (className) {
  svgContent = svgContent.replace('<svg', `<svg class="${className}"`);
}

svgContent = svgContent.replace('<svg', `<svg data-icon-id="${uniqueId}"`);

// FORCER LA COULEUR SI SPÉCIFIÉE
if (color) {
  svgContent = svgContent.replace(/fill="[^"]*"/g, `fill="${color}"`);
  svgContent = svgContent.replace(/stroke="[^"]*"/g, `stroke="${color}"`);
}

// Injecter le gradient directement DANS le SVG
if (hoverGradient) {
  const gradientDef = hoverGradient === 'green'
    ? `<defs><radialGradient id="gradient-${uniqueId}" cx="50%" cy="50%" r="0%"><stop offset="0%" stop-color="#51EB96"/><stop offset="100%" stop-color="#E8F444"/></radialGradient></defs>`
    : `<defs><radialGradient id="gradient-${uniqueId}" cx="50%" cy="50%" r="0%"><stop offset="0%" stop-color="#FF7957"/><stop offset="100%" stop-color="#F3471C"/></radialGradient></defs>`;
  
  svgContent = svgContent.replace('>', `>${gradientDef}`);
}

const wrapperClass = `icon-wrapper ${hoverGradient ? `icon-hover-${hoverGradient}` : ''}`;
---
<div class:list={[wrapperClass, "inline-block"]} data-icon-id={uniqueId}>
  <Fragment set:html={svgContent} />
</div>

<!-- Le script reste identique -->
<script>
  import gsap from 'gsap';
 
  function initIconAnimations() {
    const iconWrappers = document.querySelectorAll('.icon-wrapper[class*="icon-hover-"]');
    gsap.killTweensOf(".icon-wrapper[class*='icon-hover-'] svg radialGradient");

    iconWrappers.forEach((wrapper) => {
      if (wrapper.dataset.animationInitialized) return;
      wrapper.dataset.animationInitialized = "true";

      const link = wrapper.closest('a');
      const svg = wrapper.querySelector('svg');
      if (!link || !svg) return;
      
      const iconId = svg.getAttribute('data-icon-id');
      const gradientId = `gradient-${iconId}`;
      const gradient = svg.querySelector(`#${gradientId}`);
      const paths = svg.querySelectorAll('path, circle, rect, polygon');
      
      if (!gradient) {
        console.error(`Gradient ${gradientId} not found in`, svg);
        return;
      }
      
      paths.forEach(el => {
        el.dataset.originalFill = el.getAttribute('fill') || 'currentColor';
      });
      
      const enterAnim = () => {
        gradient.setAttribute('r', '0%');
        paths.forEach(el => {
          el.setAttribute('fill', `url(#${gradientId})`);
        });
        
        gsap.to(gradient, {
          attr: { r: '150%' },
          duration: 0.6,
          ease: 'power2.out'
        });
      };
      
      const leaveAnim = () => {
        gsap.to(gradient, {
          attr: { r: '20%' },
          duration: 0.4,
          ease: 'power2.in',
          onComplete: () => {
            paths.forEach(el => {
              el.setAttribute('fill', el.dataset.originalFill);
            });
          }
        });
      };

      link.addEventListener('mouseenter', enterAnim);
      link.addEventListener('mouseleave', leaveAnim);

      wrapper.cleanup = () => {
        link.removeEventListener('mouseenter', enterAnim);
        link.removeEventListener('mouseleave', leaveAnim);
      }
    });
  }

  initIconAnimations();
  document.addEventListener('astro:after-swap', initIconAnimations);

  document.addEventListener('astro:before-swap', () => {
    document.querySelectorAll('.icon-wrapper[class*="icon-hover-"]').forEach(wrapper => {
      if (wrapper.cleanup) {
        wrapper.cleanup();
      }
    });
  });
</script>
