---
// src/components/Icon.astro
export interface Props {
  name: string;
  class?: string;
  hoverGradient?: 'orange' | 'green';
}
const { name, class: className, hoverGradient } = Astro.props;
const icons = import.meta.glob('/src/assets/*.svg', { as: 'raw' });
const iconPath = `/src/assets/${name}.svg`;
if (!icons[iconPath]) {
  console.error(`L'icône "${name}" n'a pas été trouvée dans /src/assets/`);
  return null;
}
let svgContent = await icons[iconPath]();

const uniqueId = `${name}-${Math.random().toString(36).substr(2, 9)}`;

if (className) {
  svgContent = svgContent.replace('<svg', `<svg class="${className}"`);
}

svgContent = svgContent.replace('<svg', `<svg data-icon-id="${uniqueId}"`);

// Injecter le gradient directement DANS le SVG
if (hoverGradient) {
  const gradientDef = hoverGradient === 'green'
    ? `<defs><radialGradient id="gradient-${uniqueId}" cx="50%" cy="50%" r="0%"><stop offset="0%" stop-color="#51EB96"/><stop offset="100%" stop-color="#E8F444"/></radialGradient></defs>`
    : `<defs><radialGradient id="gradient-${uniqueId}" cx="50%" cy="50%" r="0%"><stop offset="0%" stop-color="#FF7957"/><stop offset="100%" stop-color="#F3471C"/></radialGradient></defs>`;
  
  svgContent = svgContent.replace('>', `>${gradientDef}`);
}

const wrapperClass = `icon-wrapper ${hoverGradient ? `icon-hover-${hoverGradient}` : ''}`;
---
<div class:list={[wrapperClass, "inline-block"]} data-icon-id={uniqueId}>
  <Fragment set:html={svgContent} />
</div>

<script>
  import gsap from 'gsap';
  
  document.addEventListener('DOMContentLoaded', () => {
    const iconWrappers = document.querySelectorAll('.icon-wrapper[class*="icon-hover-"]');
    
    iconWrappers.forEach((wrapper) => {
      const link = wrapper.closest('a');
      const svg = wrapper.querySelector('svg');
      if (!link || !svg) return;
      
      const iconId = svg.getAttribute('data-icon-id');
      const gradientId = `gradient-${iconId}`;
      const gradient = svg.querySelector(`#${gradientId}`);
      const paths = svg.querySelectorAll('path, circle, rect, polygon');
      
      if (!gradient) {
        console.error(`Gradient ${gradientId} not found in`, svg);
        return;
      }
      
      // Sauvegarder les couleurs originales
      paths.forEach(el => {
        el.dataset.originalFill = el.getAttribute('fill') || 'currentColor';
      });
      
      link.addEventListener('mouseenter', () => {
        // Reset le rayon à 0%
        gradient.setAttribute('r', '0%');
        
        // Appliquer le gradient
        paths.forEach(el => {
          el.setAttribute('fill', `url(#${gradientId})`);
        });
        
        // Animer le rayon
        gsap.to(gradient, {
          attr: { r: '150%' },
          duration: 0.6,
          ease: 'power2.out'
        });
      });
      
      link.addEventListener('mouseleave', () => {
        // Rétrécir le gradient
        gsap.to(gradient, {
          attr: { r: '20%' },
          duration: 0.4,
          ease: 'power2.in',
          onComplete: () => {
            // Restaurer les couleurs originales
            paths.forEach(el => {
              el.setAttribute('fill', el.dataset.originalFill);
            });
          }
        });
      });
    });
  });
</script>

